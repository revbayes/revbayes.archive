################################################################################
#
# RevBayes Example: Inference for of biogeographic range data
#
# authors: Michael Landis
#
################################################################################

n_species <- 40
n_nodes <- 2 * n_species - 1
#atlas_fn <- "earth23.atlas.txt"
#atlas_fn <- "100area.atlas.txt"
atlas_fn <- "area5.atlas.txt"
in_fp <- "/Users/mlandis/Documents/code/revbayes-code/examples/data/"
out_fp <- "/Users/mlandis/data/bayarea/output/"
out_str <- "range_sim"
atlas <- readAtlas(in_fp + atlas_fn)
n_areas <- atlas.nAreas()

#######
# tree
#######

# Species names
for (i in 1:n_species) {
	names[i] <- "Taxon_" + i
}

# Birth-Death process priors
speciation ~ exponential(10.0)
extinction ~ exponential(20.0)
tree_height ~ unif(0.0,500.0)

# override drawn values
tree_height.setValue(200.0)
speciation.setValue(0.006)
extinction.setValue(0.005)

# Species tree from birth-death process
tree ~ cBDP(lambda=speciation, mu=extinction, rootAge=tree_height, nTaxa=n_species, names=names)
#tree <- readTrees(in_fp + "16tip_100areas.nex")[1]


#########################
# range evolution model #
#########################

fe <- true # forbid extinction
uc <- false # use cladogenesis
uad <- true # use area adjacency
uav <- true # use area availability
ud <- false # use distance

# Per-area gain and loss rates 
#   glr[1]: 1->0, glr[2]: 0->1
glr[1] 		~ dnExponential(1.0/0.02)
glr[2] 		~ dnExponential(1.0/0.002)
glr[1].setValue(0.02)
glr[2].setValue(0.002)
Q_site 		:= fnFreeBinary(glr)

# dp is the distance-dependence power parameter, beta
dp          ~ dnExponential(10.0)
dp.setValue(0.000001)

# grm is the geographical rate modifier function, eta
grm         := fnBiogeoGRM(atlas=atlas, distancePower=dp, useAdjacency=uad, useAvailable=uav, useDistance=ud)

# Q models the dispersal-extinction process (CTMC)
Q_area      := fnBiogeoDE(gainLossRates=Q_site, geoRateMod=grm, numAreas=n_areas, forbidExtinction=true)
#Q_area      := fnBiogeoDE(gainLossRates=Q_site, numAreas=n_areas, forbidExtinction=fe)

# csf models the cladogenic state frequencies (sympatry, peripatry, allopatry)
P_csf 		~  dnDirichlet([100,1,1])

# M is focal model, the range data given the tree, the atlas, and the DEC process

d           ~  dnPhyloDACTMC(tree=tree, Q=Q_area, C=P_csf, type="Biogeo", forbidExtinction=fe, useCladogenesis=uc)
d.redraw()


# We need to save the species tree, the gene trees, and the gene alignments
# Saving the species tree
write(tree, filename=in_fp + "range.tree")

# Saving the gene alignments
writeNexus(d, filename=in_fp+"range.nex")

# clamp simulated data?
d.clamp(d)

# model
my_model <- model(glr)

# monitors
nGens <- 5000
#monitors[1] <- screenmonitor(printgen=10, glr, P_csf, dp)
#monitors[2] <- filemonitor(filename=out_fp+out_str+".parameters.txt", printgen=10, glr, P_csf, dp)
monitors[1] <- screenmonitor(printgen=10, glr)
monitors[2] <- filemonitor(filename=out_fp+out_str+".parameters.txt", printgen=10, glr)
monitors[3] <- mnCharHistoryNewick(filename=out_fp+out_str+".events.txt", ctmc=d, tree=tree, printgen=10, style="events")
monitors[4] <- mnCharHistoryNewick(filename=out_fp+out_str+".counts.txt", ctmc=d, tree=tree, printgen=10, style="counts")
monitors[5] <- mnCharHistoryNhx(filename=out_fp+out_str+".nhx.txt", ctmc=d, tree=tree, atlas=atlas, samplegen=10, maxgen=nGens, burnin=0.25)


# moves
mi <- 0
moves[mi++] <- mvScale(x=glr[1], lambda=0.5, tune=false, weight=5.0)
moves[mi++] <- mvScale(x=glr[2], lambda=0.5, tune=false, weight=5.0)
moves[mi++] <- mvCharacterHistory(ctmc=d, qmap=Q_area, tree=tree, lambda=0.1, type="Biogeo", graph="branch", weight=n_nodes/1.0)
moves[mi++] <- mvCharacterHistory(ctmc=d, qmap=Q_area, tree=tree, lambda=0.1, type="Biogeo", graph="node", weight=n_nodes/2.0)
moves[mi++] <- mvCharacterHistory(ctmc=d, qmap=Q_area, tree=tree, lambda=0.5, type="Biogeo", graph="branch", weight=n_nodes/2.0)
moves[mi++] <- mvCharacterHistory(ctmc=d, qmap=Q_area, tree=tree, lambda=0.5, type="Biogeo", graph="node", weight=n_nodes/4.0)

# MCMC
my_mcmc <- mcmc(my_model, monitors, moves)
#my_mcmc.burnin(generations=500, tuningInterval=50)
my_mcmc.run(generations=nGens)





