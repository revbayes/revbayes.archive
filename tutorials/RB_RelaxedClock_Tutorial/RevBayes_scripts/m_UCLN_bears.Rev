############################################################################################
#   File: timetree tutorial UCLN relaxed-clock model specification file
############################################################################################

###################################################
############ UCLN model on branch rates ###########
###################################################

### the variable for the base rate
### with a lognormal prior
### and a scale move
br_M <- 5.4E-3
br_s <- 0.05
br_mu <- ln(br_M) - ((br_s * br_s) * 0.5)
base_rate ~ dnLnorm(br_mu, br_s)
moves[mi++] = mvScale(base_rate,lambda=0.25,tune=true,weight=5.0)

### get the number of branches in the tree
n_branches <- 2 * n_taxa - 2

### the rate along each branch is assigned a lognormal prior
### the expectation of the lognormal is the ucln_mean, and will be given an exponential hyperprior
ucln_mean ~ dnExponential(2.0)
### we will also estimate the standard deviation of the lognormal (ucln_sigma) with an exponential hyperprior
ucln_sigma ~ dnExponential(3.0)
### we can create deterministic nodes for the variance and mu of the lognormal
ucln_var := ucln_sigma * ucln_sigma
ucln_mu := ln(ucln_mean) - (ucln_var * 0.5)
### both the ucln_mean and ucln_sigma will be operated on by scale moves
moves[mi++] = mvScale(ucln_mean, lambda=1.0, tune=true, weight=4.0)
moves[mi++] = mvScale(ucln_sigma, lambda=0.5, tune=true, weight=4.0)

### now we will create a vector of stochastic nodes 
### each element in the vector represents a branch rate
### the indices of the vector correspond to branch indices in the tree
### using a for-lop initialize the branch rates and assign a move to each one
for(i in 1:n_branches){
	branch_rates[i] ~ dnLnorm(ucln_mu, ucln_sigma)
	moves[mi++] = mvScale(branch_rates[i],lambda=1.0,tune=true,weight=2.0)
}
### add 2 more moves on the branch rate vector
moves[mi++] = mvVectorScale(branch_rates,lambda=1.0,tune=true,weight=2.0) 
moves[mi++] = mvVectorSingleElementScale(branch_rates,lambda=30.0,tune=true,weight=1.0) 

### the branch-rates used in the phylogenetic CTMC are a function of the DPP branch rates and the base rate
branch_subrates := branch_rates * base_rate

### a helpful parameter to monitor
mean_rt := mean(branch_rates) 

### set up the GTR model and instantaneous rate matrix from file
source("RevBayes_scripts/m_GTR.Rev")

### the full phylogenetic CTMC
phySeq ~ dnPhyloCTMC(tree=timetree, Q=Q, branchRates=branch_subrates, nSites=n_sites, type="DNA")

### attach the observed sequence data
phySeq.clamp(D)

